<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opencv JS</title>
    <script async src="./libraries/opencv/opencv.js" onload="openCvReady();"></script>
    <script src="./libraries/opencv/utils.js"></script>
</head>
<body>
<video id="cam_input" height="480" width="640"></video>
<canvas id="canvas_output"></canvas>
</body>
<script type="text/JavaScript">
    function openCvReady() {
        cv['onRuntimeInitialized'] = () => {
            let video = document.getElementById("cam_input"); // video is the id of video tag
            navigator.mediaDevices.getUserMedia({video: true, audio: false})
                .then(function (stream) {
                    video.srcObject = stream;
                    video.play();
                })
                .catch(function (err) {
                    console.log("An error occurred! " + err);
                });
            let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
            let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
            let cap = new cv.VideoCapture(cam_input);
            const FPS = 24;

            // https://medium.com/@muehler.v/simple-hand-gesture-recognition-using-opencv-and-javascript-eb3d6ced28a0
            //////////////////////// 1. Preparing the binary mask
            // segmenting by skin color (has to be adjusted)


            const blue = new cv.Scalar(255, 0, 0);
            const green = new cv.Scalar(0, 255, 0);
            const red = new cv.Scalar(0, 0, 255);


            const makeHandMask = (img) => {
                // filter by skin color
                var imgHLS = new cv.Mat();
                cv.cvtColor(img, imgHLS, cv.COLOR_BGR2HLS);

                // NODEJS: const skinColorLower = hue => new cv.Scalar(hue, 0.1 * 255, 0.05 * 255); // hue 0
                let skinColorLower = new cv.Mat(imgHLS.rows, imgHLS.cols, imgHLS.type(), [0.0, 0.1 * 255, 0.05 * 255, 255]);

                // NODEJS: const skinColorUpper = hue => new cv.Scalar(hue, 0.8 * 255, 0.6 * 255); // hue 15
                let skinColorUpper = new cv.Mat(imgHLS.rows, imgHLS.cols, imgHLS.type(), [15.0, 0.8 * 255, 0.6 * 255, 0]);

                //const rangeMask = imgHLS.inRange(skinColorLower(0), skinColorUpper(15));
                var rangeMask = new cv.Mat();
                cv.inRange(imgHLS, skinColorLower, skinColorUpper, rangeMask);


                // remove noise
                // NODEJS: const blurred = rangeMask.blur(new cv.Size(10, 10));
                let blurred = new cv.Mat();
                cv.blur(rangeMask, blurred, new cv.Size(10, 10));


                // NODEJS: const thresholded = blurred.threshold(200, 255, cv.THRESH_BINARY);
                let thresholded = new cv.Mat();
                cv.threshold(blurred, thresholded, 200, 255, cv.THRESH_BINARY);

                return thresholded;
            };

            const getHandContour = (handMask) => {
                const mode = cv.RETR_EXTERNAL;
                const method = cv.CHAIN_APPROX_SIMPLE;

                // NODEJS: const contours = handMask.findContours(mode, method);
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(handMask, contours, hierarchy, mode, method);

                // largest contour
                // NODEJS: return contours.sort((c0, c1) => c1.area - c0.area)[0];
                return contours.get(0);
            };


            // get the polygon from a contours hull such that there
            // will be only a single hull point for a local neighborhood
            const getRoughHull = (contour, maxDist) => {
                // get hull indices and hull points
                const hullIndices = contour.convexHullIndices();
                const contourPoints = contour.getPoints();
                const hullPointsWithIdx = hullIndices.map(idx => ({
                    pt: contourPoints[idx],
                    contourIdx: idx
                }));
                const hullPoints = hullPointsWithIdx.map(ptWithIdx => ptWithIdx.pt);

                // group all points in local neighborhood
                const ptsBelongToSameCluster = (pt1, pt2) => ptDist(pt1, pt2) < maxDist;
                const {labels} = cv.partition(hullPoints, ptsBelongToSameCluster);
                const pointsByLabel = new Map();
                labels.forEach(l => pointsByLabel.set(l, []));
                hullPointsWithIdx.forEach((ptWithIdx, i) => {
                    const label = labels[i];
                    pointsByLabel.get(label).push(ptWithIdx);
                });

                // map points in local neighborhood to most central point
                const getMostCentralPoint = (pointGroup) => {
                    // find center
                    const center = getCenterPt(pointGroup.map(ptWithIdx => ptWithIdx.pt));
                    // sort ascending by distance to center
                    return pointGroup.sort(
                        (ptWithIdx1, ptWithIdx2) => ptDist(ptWithIdx1.pt, center) - ptDist(ptWithIdx2.pt, center)
                    )[0];
                };
                const pointGroups = Array.from(pointsByLabel.values());
                // return contour indeces of most central points
                return pointGroups.map(getMostCentralPoint).map(ptWithIdx => ptWithIdx.contourIdx);
            };


            const getHullDefectVertices = (handContour, hullIndices) => {

                // NODEJS: const defects = handContour.convexityDefects(hullIndices);
                let contour1 = handContour;
                let convexhull1 = hullIndices;
                let defects = new cv.Mat();
                cv.convexityDefects(contour1, convexhull1, defects);


                const handContourPoints = handContour.getPoints();

                // get neighbor defect points of each hull point
                const hullPointDefectNeighbors = new Map(hullIndices.map(idx => [idx, []]));
                defects.forEach((defect) => {
                    const startPointIdx = defect.at(0);
                    const endPointIdx = defect.at(1);
                    const defectPointIdx = defect.at(2);
                    hullPointDefectNeighbors.get(startPointIdx).push(defectPointIdx);
                    hullPointDefectNeighbors.get(endPointIdx).push(defectPointIdx);
                });

                return Array.from(hullPointDefectNeighbors.keys())
                    // only consider hull points that have 2 neighbor defects
                    .filter(hullIndex => hullPointDefectNeighbors.get(hullIndex).length > 1)
                    // return vertex points
                    .map((hullIndex) => {
                        const defectNeighborsIdx = hullPointDefectNeighbors.get(hullIndex);
                        return ({
                            pt: handContourPoints[hullIndex],
                            d1: handContourPoints[defectNeighborsIdx[0]],
                            d2: handContourPoints[defectNeighborsIdx[1]]
                        });
                    });
            };


            const filterVerticesByAngle = (vertices, maxAngleDeg) =>
                vertices.filter((v) => {
                    const sq = x => x * x;
                    const a = v.d1.sub(v.d2).norm();
                    const b = v.pt.sub(v.d1).norm();
                    const c = v.pt.sub(v.d2).norm();
                    const angleDeg = Math.acos(((sq(b) + sq(c)) - sq(a)) / (2 * b * c)) * (180 / Math.PI);
                    return angleDeg < maxAngleDeg;
                });




            function processVideo() {
                console.log("function processVideo");

                let begin = Date.now();
                cap.read(src);

                src.copyTo(dst);


                let resizedImg = new cv.Mat();
                let dsize = new cv.Size(640, 640);
                cv.resize(dst, resizedImg, dsize, 0, 0, cv.INTER_AREA);

                const handMask = makeHandMask(resizedImg);
                const handContour = getHandContour(handMask);
                console.log("function processVideo");

                if (handContour) {
                    console.log("Hand")
                    console.log(handContour);

                    const maxPointDist = 25;
                    const hullIndices = getRoughHull(handContour, maxPointDist);

                    // get defect points of hull to contour and return vertices
                    // of each hull point to its defect points
                    const vertices = getHullDefectVertices(handContour, hullIndices);

                    // fingertip points are those which have a sharp angle to its defect points
                    const maxAngleDeg = 60;
                    const verticesWithValidAngle = filterVerticesByAngle(vertices, maxAngleDeg);

                    const result = resizedImg.copy();
                    // draw bounding box and center line


                    var xx = handContour;
                    cv.imshow("canvas_output", xx);
                } else {
                    console.log("No Hand")
                }
                //let src = cv.imread('canvasInput');
                //let dst = new cv.Mat();
                //let dsize = new cv.Size(300, 300);
                // You can try more different parameters
                //cv.resize(src, dst, dsize, 0, 0, cv.INTER_AREA);
                //cv.imshow('canvasOutput', dst);
                //src.delete(); dst.delete();


                // schedule next one.
                let delay = 1000 / FPS - (Date.now() - begin);
                setTimeout(processVideo, delay);
            }

            // schedule first one.
            setTimeout(processVideo, 0);
            console.log("End of code");
        };
    }
</script>
</html>